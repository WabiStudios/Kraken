struct Citizen {
  let name: Str
  let age: Int

  // `name` is inferred to be of type `Str`.
  init(name) {
    self.name = name
    self.age = 0
  }

  fn randomName() -> Str {
    ["Steve Apple", "John Smith"].randomChoice()
  }

  // Return type is inferred as `(Str, Optional<Str>)`
  fn parsedName(self) {
    let parts = self.name.split(" ", maxSplits: 1)
    return (parts[0], parts.last)
  }

  // We could infer that it throws for the user, but that might not be a good idea. Note that
  // this method definitely shouldn't throw in any sane software, this is just an example.
  fn incrementAge(mut self) throws {
    self.age += 1
    if self.age > 100 || Int.random(0, 80) == 0 {
      throw "Citizen died"
    }
  }
}

fn main() {
  let stackotter = Citizen("stackotter")
  for _ in 0..<80 {
    do {
      try stackotter.incrementAge()
    } catch {
      eprint("stackotter died at {stackotter.age}")
      exit(1)
    }
  }

  print("stackotter is {stackotter.age}")
  let (first, last) = stackotter.parsedName()
  print("stackotter's first name is {first} and his last name is \(last ?? "unknown")")
}
